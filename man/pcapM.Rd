% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pcapM.R
\name{pcapM}
\alias{pcapM}
\title{A wrapper for pcaMethods function implementations}
\usage{
pcapM(myMat, nPcs = 2, method = "ppca", seed = NA,
  threshold = 1e-04, maxIterations = 1000, center = TRUE,
  scale = c("none", "pareto", "vector", "uv"), loglike = TRUE,
  verbose = TRUE)
}
\arguments{
\item{myMat}{\code{matrix} -- Data matrix with 
variables in columns and observations in rows. The
data may contain missing values, denoted as \code{NA}.}

\item{nPcs}{\code{numeric} -- Number of components used for
re-estimation. Choosing few components may decrease the
estimation precision.}

\item{method}{\code{c("ppca", "bpca")} -- frequentist or
Bayesian estimation of model parameters.}

\item{seed}{\code{numeric} -- the random number seed used, useful
to specify when comparing algorithms.}

\item{threshold}{\code{numeric} -- Convergence threshold. 
If the increase in precision of an update
falls below this then the algorithm is stopped.}

\item{maxIterations}{\code{numeric} -- Maximum number of estimation
steps.}

\item{center}{\code{logical} -- should the data be centered?}

\item{scale}{\code{c("none", "pareto", "vector", "uv")} --
which method of scaling should be used? See 
\code{\link[pcaMethods:pca]{pca}}.}

\item{loglike}{\code{logical} -- should the log-likelihood
of the estimated parameters be returned? See Details.}

\item{verbose}{\code{logical} -- verbose intermediary 
algorithm output.}
}
\value{
{A \code{list} of 5 or 7 elements, depending on the value
of \code{loglike}:
\describe{
\item{W}{\code{matrix} -- the estimated loadings.}
\item{sigmaSq}{\code{numeric} -- the estimated isotropic variance.}
\item{Sigma}{\code{matrix} -- the estimated covariance matrix.}
\item{m}{\code{numeric} -- the estimated mean vector.}
\item{logLikeObs}{\code{numeric} -- the log-likelihood value
of the observed data given the estimated parameters.}
\item{logLikeImp}{\code{numeric} -- the log-likelihood value
of the imputed data given the estimated parameters.}
\item{pcaMethodsRes}{\code{class} -- 
  see \linkS4class{pcaRes}.}
}}
}
\description{
Implements the equivalent of 
  \code{\link[pcaMethods:pca]{pca}}.
  This function preprocesses the data as specified by the user,
  then calls ppcapM or bpcapM, and finally handles this output
  to return a list. One element of the output is a pcaRes object.
}
\details{
See \code{\link{ppcapM}} and \code{\link{bpcapM}} for 
  the algorithm specifics. \code{loglike} indicates whether 
  log-likelihood values for the resulting estimates should 
  be computed. This can be useful to compare different algorithms.
}
\examples{
# simulate a dataset from a zero mean factor model X = Wz + epsilon
# start off by generating a random binary connectivity matrix
n.factors <- 5
n.genes <- 200
# with dense connectivity
# set.seed(20)
conn.mat <- matrix(rbinom(n = n.genes*n.factors,
                          size = 1, prob = 0.7), c(n.genes, n.factors))

# now generate a loadings matrix from this connectivity
loading.gen <- function(x){
  ifelse(x==0, 0, rnorm(1, 0, 1))
}

W <- apply(conn.mat, c(1, 2), loading.gen)

# generate factor matrix
n.samples <- 100
z <- replicate(n.samples, rnorm(n.factors, 0, 1))

# generate a noise matrix
sigma.sq <- 0.1
epsilon <- replicate(n.samples, rnorm(n.genes, 0, sqrt(sigma.sq)))

# by the ppca equations this gives us the data matrix
X <- W\%*\%z + epsilon
WWt <- tcrossprod(W)
Sigma <- WWt + diag(sigma.sq, n.genes)

# select 10\% of entries to make missing values
missFrac <- 0.1
inds <- sample(x = 1:length(X),
               size = ceiling(length(X)*missFrac),
               replace = FALSE)

# replace them with NAs in the dataset
missing.dataset <- X
missing.dataset[inds] <- NA

# run ppca
ppm <- pcapM(t(missing.dataset), nPcs=5, method="bpca", seed=2009, 
maxIterations=1000, center=TRUE, loglike=TRUE, verbose=TRUE)

}
